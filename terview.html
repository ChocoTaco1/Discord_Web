<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #renderCanvas {
            width: 100vw; /* Use full viewport width */
            height: 100vh; /* Use full viewport height */
            touch-action: none;
        }
        #buttonContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            gap: 10px; /* Space between buttons */
        }
        #greyscaleCanvas {
			display: block; /* Changed to block */
			position: absolute;
			bottom: 10px; /* Position from the bottom */
			left: 10px; /* Position from the left */
			z-index: 10;
			border: 1px solid black; /* Optional: Add a border for visibility */
		}
    </style>
</head>
<body>
    <div id="buttonContainer">
        <input type="file" id="fileInput" accept=".ter" />
        <button id="toggleViewButton">Switch to Shaded View</button>
        <button id="exportButton">Export Greyscale</button>
        <label for="scaleSlider">Export Scale (1-16): <span id="scaleValue">1</span></label>
        <input type="range" id="scaleSlider" min="1" max="16" value="1" />
    </div>
    <canvas id="renderCanvas"></canvas>
    <canvas id="greyscaleCanvas" width="256" height="256"></canvas> <!-- Canvas for grayscale image -->

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        // Camera and lighting setup
        const camera = new BABYLON.ArcRotateCamera("camera1", Math.PI / 2, Math.PI / 3, 2048, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
		camera.wheelDeltaPercentage = 0.005; // Adjust this value for faster zoom (default is 0.01)
        const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0.0, 1.0, 0.0), scene);
        light.intensity = 0.75;

        const size = 256; // Size of the terrain
        const scaleFactor = 8; // Scale factor for X and Z axes
        let mHeight = [];
        let map; // Reference to the terrain mesh

        // Function to create terrain mesh using height data
        function createTerrain() {
            // Dispose of the previous terrain mesh if it exists
            if (map) {
                map.dispose();
            }

            const mapSubX = size; // Points along the X axis
            const mapSubZ = size; // Points along the Z axis
            const mapData = new Float32Array(mapSubX * mapSubZ * 3); // 3 float values per point: x, y, z

            const paths = [];
            for (let l = 0; l < mapSubZ; l++) {
                const path = [];
                for (let w = 0; w < mapSubX; w++) {
                    const x = (w - mapSubX * 0.5) * scaleFactor; // Adjusted by scale factor
                    const z = (l - mapSubZ * 0.5) * scaleFactor; // Adjusted by scale factor
                    const y = mHeight[l * mapSubX + w]; // Use loaded height data

                    mapData[3 * (l * mapSubX + w)] = x;
                    mapData[3 * (l * mapSubX + w) + 1] = y;
                    mapData[3 * (l * mapSubX + w) + 2] = z;

                    path.push(new BABYLON.Vector3(x, y, z));
                }
                paths.push(path);
            }

            // Create the new terrain mesh
            map = BABYLON.MeshBuilder.CreateRibbon("terrain", { pathArray: paths, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            map.position.y = 0;

            // Create a flat shading material
            const flatMaterial = new BABYLON.StandardMaterial("flatMaterial", scene);
            flatMaterial.wireframe = false; // Set to false for shaded view
            flatMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8); // Set color to something natural
            flatMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No specular highlights for flat shading
            flatMaterial.emissiveColor = new BABYLON.Color3(0, 0, 0); // No emissive color

            // Set the material to the mesh
            map.material = flatMaterial;

            console.log("Terrain created successfully.");
            generateGreyscaleImage(); // Generate the grayscale image
        }

        // Function to load and parse the .ter file
        function loadTerFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const buffer = e.target.result;
                const dataView = new DataView(buffer);

                let offset = 0;
                const version = dataView.getUint8(offset++);
                console.log(`Terrain Version: ${version}`);

                mHeight = [];
                for (let i = 0; i < size * size; i++) {
                    let height = dataView.getUint16(offset, true); // true for little-endian
                    height = height * 0.03125; // Convert height to meters
                    offset += 2;
                    mHeight.push(height);
                }

                console.log(`Height Data Loaded. Min: ${Math.min(...mHeight)}, Max: ${Math.max(...mHeight)}`);

                // Once data is loaded, create the terrain
                createTerrain();
            };

            reader.readAsArrayBuffer(file);
        }

        // Function to generate a grayscale image from height data
        function generateGreyscaleImage() {
            const greyscaleCanvas = document.getElementById('greyscaleCanvas');
            const context = greyscaleCanvas.getContext('2d');
            const imageData = context.createImageData(size, size);

            // Calculate min and max heights for normalization
            const minHeight = Math.min(...mHeight);
            const maxHeight = Math.max(...mHeight);

            for (let i = 0; i < mHeight.length; i++) {
                // Normalize height to 0-1 range
                const normalizedHeight = (mHeight[i] - minHeight) / (maxHeight - minHeight);
                // Map to grayscale value (0-255)
                const grayValue = Math.floor(normalizedHeight * 255);

                imageData.data[i * 4] = grayValue; // Red
                imageData.data[i * 4 + 1] = grayValue; // Green
                imageData.data[i * 4 + 2] = grayValue; // Blue
                imageData.data[i * 4 + 3] = 255; // Alpha
            }

            context.putImageData(imageData, 0, 0);
            greyscaleCanvas.style.display = 'block'; // Show the grayscale canvas
        }

        // Bilinear interpolation function
        function bilinearInter(x1, y1, x2, y2, x, y, v1, v2, v3, v4) {
            let w11 = (((x2 - x) * (y2 - y)) / ((x2 - x1) * (y2 - y1))) * v1; // x1 y1
            let w21 = (((x - x1) * (y2 - y)) / ((x2 - x1) * (y2 - y1))) * v2; // x2 y1
            let w12 = (((x2 - x) * (y - y1)) / ((x2 - x1) * (y2 - y1))) * v3; // x1 y2
            let w22 = (((x - x1) * (y - y1)) / ((x2 - x1) * (y2 - y1))) * v4; // x2 y2
            return w11 + w21 + w12 + w22;
        }

        // Function to resize and export the grayscale image
        function exportScaledImage(scale) {
            const greyscaleCanvas = document.getElementById('greyscaleCanvas');
            const resizeTo = size * scale;
            const img1 = new ImageData(resizeTo, resizeTo);
            const max = Math.max(...mHeight);
            const min = Math.min(...mHeight);

            for (let y = 0; y < resizeTo; y++) {
                for (let x = 0; x < resizeTo; x++) {
                    const nx = Math.floor(x / scale);
                    const ny = Math.floor(y / scale);
                    const nxedge = (nx !== 255) ? 1 : -255;
                    const nyedge = (ny !== 255) ? 1 : -255;

                    const v1 = mHeight[nx + (ny * size)];
                    const v2 = mHeight[(nx + nxedge) + (ny * size)];
                    const v3 = mHeight[nx + ((ny + nyedge) * size)];
                    const v4 = mHeight[(nx + (nxedge)) + ((ny + nyedge) * size)];

                    const linval = bilinearInter(
                        Math.floor(x / scale) * scale,
                        Math.floor(y / scale) * scale,
                        (Math.floor(x / scale) + 1) * scale,
                        (Math.floor(y / scale) + 1) * scale,
                        x,
                        y,
                        v1,
                        v2,
                        v3,
                        v4
                    );

                    const dif = max - min;
                    const colRange = 255 / dif;
                    const color = Math.floor((linval - min) * colRange);

                    img1.data[x * 4 + y * 4 * resizeTo] = color;     // Red
                    img1.data[x * 4 + y * 4 * resizeTo + 1] = color; // Green
                    img1.data[x * 4 + y * 4 * resizeTo + 2] = color; // Blue
                    img1.data[x * 4 + y * 4 * resizeTo + 3] = 255;   // Alpha
                }
            }

            // Create a new canvas for the scaled image
            const scaledCanvas = document.createElement('canvas');
            scaledCanvas.width = resizeTo;
            scaledCanvas.height = resizeTo;
            const scaledContext = scaledCanvas.getContext('2d');
            scaledContext.putImageData(img1, 0, 0);

            // Create a link to download the image
            const link = document.createElement('a');
            link.download = 'heightmap.png';
            link.href = scaledCanvas.toDataURL('image/png');
            link.click();
        }

        // Button to export the grayscale image as PNG
        document.getElementById('exportButton').addEventListener('click', function() {
            const scale = parseInt(document.getElementById('scaleSlider').value, 10);
            exportScaledImage(scale);
        });

        // Update the scale value display when slider changes
        document.getElementById('scaleSlider').addEventListener('input', function() {
            const scaleValue = document.getElementById('scaleValue');
            scaleValue.textContent = this.value;
        });

        // Listen for file input change to load the .ter file
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                console.log(`Loading file: ${file.name}`);
                // Reset the terrain first
                mHeight = [];
                if (map) {
                    map.dispose(); // Dispose of the previous terrain mesh
                    map = null; // Reset the reference
                }
                loadTerFile(file);
            } else {
                console.error("No file selected.");
            }
        });

        // Button to toggle between wireframe and shaded view
        document.getElementById('toggleViewButton').addEventListener('click', function() {
            const material = map.material;
            material.wireframe = !material.wireframe; // Toggle wireframe property

            // Update button text based on the current view
            this.textContent = material.wireframe ? 'Switch to Shaded View' : 'Switch to Wireframe View';
        });

        // Render loop
        engine.runRenderLoop(function() {
            scene.render();
        });

        // Handle window resizing
        window.addEventListener('resize', function() {
            engine.resize();
        });
    </script>
</body>
</html>
